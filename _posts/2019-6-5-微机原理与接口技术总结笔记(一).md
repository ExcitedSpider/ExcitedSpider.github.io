---
layout: post
title: "微机原理与接口技术总结笔记(1)"
date: 2019-6-6
excerpt: "IA-32/x86处理器架构：数据类型，工作模式，寄存器，寻址方式"
tags: [IO]
comments: false
---

>  课程复习笔记
>
> 由于课程限制，所学都是16位8086处理器（IA-32实地址模式）的相关知识。

## IA-32处理器架构

### 数据类型

- 整型数据分为有符号和无符号，其中有符号数全部以补码表示。补码和原码之间转换方法为：**取反加一**。

  | 名称     | 位数 | 无符号数范围      | 有符号数范围  |
  | -------- | ---- | ----------------- | ------------- |
  | BYTE(DB) | 8    | 0~255(2^8-1)      | -128~+127     |
  | WORD(DW) | 16   | 0~65535（2^16-1） | -32768~+32767 |

- 浮点数：遵从IEEE754标准，由于课程限制省略了

- 二进制与十进制的转换问题

  - 如果是负数，需要先将补码转换为原码，再对无符号部分进行转换。

- 指针类型

  - 近指针：16位段内偏移（有效地址）
  - 远指针：16位段地址+16位段内偏移

- 字符（ASCII码）重要的如下：

  - CR - 0DH; LF - 0AH; 0 - 30H; A - 41H; a - 61H

### 工作模式

- **实地址模式** 相当于一个8086，16位的处理器。系统启动后首先进入的模式，没啥限制。学习的主要模式。
- 保护模式 拥有执行特权级别的模式，能够限制核心指令的执行，在实地址模式后进入的模式
- 虚拟8086模式 在保护模式下，隔离出多个执行环境，运行多个实地址模式下的程序。
- 系统管理模式 管理系统的模式，比如管理电源、外围设备等
- IA-32e模式，32位兼容模式或64位模式

### 实地址模式（8086）特性

- 最大存储(内存)空间：1MB，按字节BYTE编址。1MB存储被分为若干段，每段常为64KB大小。

- 大端/小端存储

  - **小端存储**：数据的低字节存放在低地址，例如一个WORD 1234H存放在首地址100H，存储为(100H)=34H, (101H)=12H，8086采用此种存储；
  - 大端正好相反；

- <span id="1">逻辑存储地址和物理存储地址</span>

  - 逻辑存储地址：段基址+段内偏移地址。

  - 物理存储地址：数据在内存空间中的线性地址。

  - 转换：逻辑存储地址的段地址左移4位，加上偏移地址，就得到了物理存储地址。

    如段地址6417H，偏移0100H，物理地址为：$6417H\times10H+0100H=64270H$

- 边缘对齐

  - 数据占N个BYTE，其存放的起始地址就是N的倍数，这样便于CPU取值。
  - 简单地说就是WORD类型的起始BYTE存放在偶数位，DWORD类型存放在4的倍数位。

### 8086寄存器

- 默认都是16位
- 通用寄存器
  - AX, BX, CX, DX可以拆分为高低8位；BP, SI, DI, SP不能拆分；
  - AX：作为端口访问指令的数据存放寄存器；INT命令的操作数。
  - DX：作为端口访问指令的地址存放寄存器
  - SP：堆栈指针寄存器，和栈操作指令相关。栈从高地址向低地址生长，即PUSH会造成SP减。
  - 可作基址BASE：BX, BP
  - 可做变址INDEX：SI, DI
  - DX+AX：乘除法扩位表示32位
- 段寄存器
  - **代码段CS，数据段DS，堆栈段SS**，附加数据段ES；前3个是默认情况下的段地址。
- 指令指针寄存器IP，只想下一条指令的偏移量
- FLAG寄存器
  - 运算状态
    - OF：溢出标志，有符号数的算数运算超出有效范围置1；判断：两相同符号的数字相加符号改变。
    - SF：符号标志，若有符号数的运算结果为负数；
    - ZF：零标识符，若运算结果为0；
    - AF：辅助进位，若BCD码运算时低4位向上进位或借位；
    - PF：奇偶标志，若运算结果低8位有偶数个1；
    - CF：进位标志，若无符号数向最高位进位或借位；
  - 控制标志
    - DF：串操作方向
    - IF：中断允许，若CPU可以响应中断请求。STI使IF=1；CLI使IF=0；

### 寻址方式

- 立即寻址

  ```assembly
  MOV AX,1234H; (AX)=1234H
  ```

- 寄存器寻址

  ```assembly
  MOV AL,CL;(AL)=(CL)
  ```

- 存储器寻址

  将数据放在存储器中，通过**有效地址(EA)**访问，其公式为$EA=基址+变址+位移$；基址必须由基址寄存器提供，变址必须由变址寄存器提供；EA作为**偏移地址**，结合**段寄存器**作为逻辑地址就可以访问存储器了，具体方法见[此](#1)。

  - 直接寻址

    ```assembly
    MOV AX, [1234H]; EA=1234H
    ```

  - 寄存器间接寻址

    ```assembly
    MOV BL, [AX]; EA=(AX)
    MOV BL, ES:[AX]; EA相同，但是使用ES作为段寄存器
    ```

  - 基址寻址

    ```assembly
    MOV BL, [BP+10H]; EA=(BP)+10H 
    MOV BL, 10H[BP];和上面一样
    ```

  - 变址寻址

    ```assembly
    MOV AX, [SI+10H]; EA=(SI)+10H
    ```

  - 基址变址寻址

    ```assembly
    MOV AX, [BP][SI+10H]; EA=(BP)+(SI)+10H
    ```

- 端口寻址

  通过端口访问外设的寻址方式，AL/AX存数据，DX存地址
  
  ```assembly
  MOV DX, 3FCH
  MOV AL, 60H
  OUT AL, DX
  ```
  
- 跳转寻址

  - 跳转分为`SHROT`8位, `NEAR`在同一段内, `FAR`在另一段内三种类型，可以不指定（不写），编译器会自己分辨；指令存储为4BYTE，其中低2BYTE为IP，高2BYTE为CS。

  - 段内直接寻址

    ```assembly
    PROG: ADD AL, 05H
    JMP SHORT PROG ; 跳转到PROG
    ```

  - 段内间接寻址

    ```assembly
    JMP BX ; 跳转到(BX)
    ```

  - 段间间接寻址

    ```assembly
    JMP FAR PTR [SI+0126H] ; EA=(SI)+0126H，取4BYTE
    ```
